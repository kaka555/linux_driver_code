/**
 * struct input_dev - represents an input device
 * @name: name of the device
 * @phys: physical path to the device in the system hierarchy
 * @uniq: unique identification code for the device (if device has it)
 * @id: id of the device (struct input_id)
 * @propbit: bitmap of device properties and quirks
 * @evbit: bitmap of types of events supported by the device (EV_KEY,
 *  EV_REL, etc.)
 * @keybit: bitmap of keys/buttons this device has
 * @relbit: bitmap of relative axes for the device
 * @absbit: bitmap of absolute axes for the device
 * @mscbit: bitmap of miscellaneous events supported by the device
 * @ledbit: bitmap of leds present on the device
 * @sndbit: bitmap of sound effects supported by the device
 * @ffbit: bitmap of force feedback effects supported by the device
 * @swbit: bitmap of switches present on the device
 * @hint_events_per_packet: average number of events generated by the
 *  device in a packet (between EV_SYN/SYN_REPORT events). Used by
 *  event handlers to estimate size of the buffer needed to hold
 *  events.
 * @keycodemax: size of keycode table
 * @keycodesize: size of elements in keycode table
 * @keycode: map of scancodes to keycodes for this device
 * @getkeycode: optional legacy method to retrieve current keymap.
 * @setkeycode: optional method to alter current keymap, used to implement
 *  sparse keymaps. If not supplied default mechanism will be used.
 *  The method is being called while holding event_lock and thus must
 *  not sleep
 * @ff: force feedback structure associated with the device if device
 *  supports force feedback effects
 * @repeat_key: stores key code of the last key pressed; used to implement
 *  software autorepeat
 * @timer: timer for software autorepeat
 * @rep: current values for autorepeat parameters (delay, rate)
 * @mt: pointer to array of struct input_mt_slot holding current values
 *  of tracked contacts
 * @mtsize: number of MT slots the device uses
 * @slot: MT slot currently being transmitted
 * @trkid: stores MT tracking ID for the current contact
 * @absinfo: array of &struct input_absinfo elements holding information
 *  about absolute axes (current value, min, max, flat, fuzz,
 *  resolution)
 * @key: reflects current state of device's keys/buttons
 * @led: reflects current state of device's LEDs
 * @snd: reflects current state of sound effects
 * @sw: reflects current state of device's switches
 * @open: this method is called when the very first user calls
 *  input_open_device(). The driver must prepare the device
 *  to start generating events (start polling thread,
 *  request an IRQ, submit URB, etc.)
 * @close: this method is called when the very last user calls
 *  input_close_device().
 * @flush: purges the device. Most commonly used to get rid of force
 *  feedback effects loaded into the device when disconnecting
 *  from it
 * @event: event handler for events sent _to_ the device, like EV_LED
 *  or EV_SND. The device is expected to carry out the requested
 *  action (turn on a LED, play sound, etc.) The call is protected
 *  by @event_lock and must not sleep
 * @grab: input handle that currently has the device grabbed (via
 *  EVIOCGRAB ioctl). When a handle grabs a device it becomes sole
 *  recipient for all input events coming from the device
 * @event_lock: this spinlock is is taken when input core receives
 *  and processes a new event for the device (in input_event()).
 *  Code that accesses and/or modifies parameters of a device
 *  (such as keymap or absmin, absmax, absfuzz, etc.) after device
 *  has been registered with input core must take this lock.
 * @mutex: serializes calls to open(), close() and flush() methods
 * @users: stores number of users (input handlers) that opened this
 *  device. It is used by input_open_device() and input_close_device()
 *  to make sure that dev->open() is only called when the first
 *  user opens device and dev->close() is called when the very
 *  last user closes the device
 * @going_away: marks devices that are in a middle of unregistering and
 *  causes input_open_device*() fail with -ENODEV.
 * @sync: set to %true when there were no new events since last EV_SYN
 * @dev: driver model's view of this device
 * @h_list: list of input handles associated with the device. When
 *  accessing the list dev->mutex must be held
 * @node: used to place the device onto input_dev_list
 */
struct input_dev {
  const char *name;
  const char *phys;
  const char *uniq;
  struct input_id id;

  unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];

  unsigned long evbit[BITS_TO_LONGS(EV_CNT)];
  unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
  unsigned long relbit[BITS_TO_LONGS(REL_CNT)];
  unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];
  unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];
  unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];
  unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];
  unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];
  unsigned long swbit[BITS_TO_LONGS(SW_CNT)];

  unsigned int hint_events_per_packet;

  unsigned int keycodemax;
  unsigned int keycodesize;
  void *keycode;

  int (*setkeycode)(struct input_dev *dev,
        const struct input_keymap_entry *ke,
        unsigned int *old_keycode);
  int (*getkeycode)(struct input_dev *dev,
        struct input_keymap_entry *ke);

  struct ff_device *ff;

  unsigned int repeat_key;
  struct timer_list timer;

  int rep[REP_CNT];

  struct input_mt_slot *mt;
  int mtsize;
  int slot;
  int trkid;

  struct input_absinfo *absinfo;

  unsigned long key[BITS_TO_LONGS(KEY_CNT)];
  unsigned long led[BITS_TO_LONGS(LED_CNT)];
  unsigned long snd[BITS_TO_LONGS(SND_CNT)];
  unsigned long sw[BITS_TO_LONGS(SW_CNT)];

  int (*open)(struct input_dev *dev);
  void (*close)(struct input_dev *dev);
  int (*flush)(struct input_dev *dev, struct file *file);
  int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);

  struct input_handle __rcu *grab;

  spinlock_t event_lock;
  struct mutex mutex;

  unsigned int users;
  bool going_away;

  bool sync;

  struct device dev;

  struct list_head  h_list;
  struct list_head  node;
};
#define to_input_dev(d) container_of(d, struct input_dev, dev)


/**
 * struct input_handle - links input device with an input handler
 * @private: handler-specific data
 * @open: counter showing whether the handle is 'open', i.e. should deliver
 *  events from its device
 * @name: name given to the handle by handler that created it
 * @dev: input device the handle is attached to
 * @handler: handler that works with the device through this handle
 * @d_node: used to put the handle on device's list of attached handles
 * @h_node: used to put the handle on handler's list of handles from which
 *  it gets events
 */
struct input_handle {

  void *private;

  int open;
  const char *name;

  struct input_dev *dev;
  struct input_handler *handler;

  struct list_head  d_node;
  struct list_head  h_node;
};




#include <linux/module.h>
#include <linux/version.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/interrupt.h>
#include <linux/irq.h>
#include <linux/sched.h>
#include <linux/pm.h>
#include <linux/sysctl.h>
#include <linux/proc_fs.h>
#include <linux/delay.h>
#include <linux/platform_device.h>
#include <linux/input.h>
#include <linux/irq.h>
#include <linux/gpio_keys.h>
#include <asm/gpio.h>

 
struct input_dev *buttons_dev;            //  定义一个input_dev结构体  
static struct ping_desc *buttons_id;          //保存dev_id,在定时器中用
static struct timer_list buttons_timer;    //定时器结构体  

struct  ping_desc{

       unsigned  char  *name;          //中断设备名称
       int            pin_irq;          //按键的外部中断标志位
       unsigned  int    pin;                //引脚
       unsigned int  irq_ctl;           //触发中断状态:   IRQ_TYPE_EDGE_BOTH
       unsigned  int    button;         //dev_id,对应键盘的 L ,  S,  空格,  enter      
};

        // KEY1 -> L
        // KEY2 -> S
        // KEY3 -> 空格
        // KEY4 -> enter
static  struct ping_desc   buttons_desc[5]=
{
       {"s1", IRQ_EINT0,   S3C2410_GPF0,  IRQ_TYPE_EDGE_BOTH,KEY_L},
       {"s2", IRQ_EINT2,   S3C2410_GPF2,  IRQ_TYPE_EDGE_BOTH,KEY_S},
       {"s3", IRQ_EINT11, S3C2410_GPG3 , IRQ_TYPE_EDGE_BOTH,KEY_SPACE},
       {"s4", IRQ_EINT19, S3C2410_GPG11,IRQ_TYPE_EDGE_BOTH,KEY_ENTER},
};

 

/*5. 写中断服务函数*/
static irqreturn_t  buttons_irq (int irq, void *dev_id)       //中断服务函数
{
       buttons_id=(struct ping_desc *)dev_id;             //保存当前的dev_id
       mod_timer(&buttons_timer, jiffies+HZ/100 );   //更新定时器值 10ms 
       return 0;
}

 

/*6.写定时器超时函数*/
void buttons_timer_function(unsigned long i)
{
   int val;
   val=s3c2410_gpio_getpin(buttons_id->pin);             //获取是什么电平 
  if(val)         //高电平,松开
       {
         /*上报事件*/
         input_event(buttons_dev,EV_KEY,buttons_id->button, 0);  //上报EV_KEY类型,button按键,0(没按下)
         input_sync(buttons_dev);         // 上传同步事件,告诉系统有事件出现                       
      }

  else      //低电平，按下
      {
         /*上报事件*/
         input_event(buttons_dev, EV_KEY, buttons_id->button, 1);  //上报EV_KEY类型,button按键,1(按下)
         input_sync(buttons_dev);       // 上传同步事件,告诉系统有事件出现
     }
}


static int buttons_init(void)   //入口函数
{
       int i;      
       buttons_dev=input_allocate_device();  //1.向内核 申请input_dev结构体
       /*2.设置input_dev ,  */
       set_bit(EV_KEY,buttons_dev->evbit);       //支持键盘事件
       set_bit(EV_REP,buttons_dev->evbit);       //支持键盘重复按事件
    
       set_bit(KEY_L,buttons_dev->keybit);                  //支持按键 L
       set_bit(KEY_S,buttons_dev->keybit);                //支持按键 S
       set_bit(KEY_SPACE,buttons_dev->keybit);      //支持按键 空格
       set_bit(KEY_ENTER,buttons_dev->keybit);     //支持按键 enter

       /*3.注册input_dev */
       input_register_device(buttons_dev);

      
       /*4. 初始化硬件:初始化定时器和中断*/      
       // KEY1 -> L
       // KEY2 -> S
       // KEY3 -> 空格
       // KEY4 -> enter
       init_timer(&buttons_timer);
       buttons_timer.function=buttons_timer_function;
       add_timer(&buttons_timer);

       for(i=0;i<4;i++)
       request_irq(buttons_desc[i].pin_irq, buttons_irq, buttons_desc[i].irq_ctl, buttons_desc[i].name, &buttons_desc[i]);

       return 0;
}


static int buttons_exit(void)  //出口函数
{
       /*7.释放中断函数,删除定时器,卸载释放驱动*/
       int i;
       for(i=0;i<4;i++)
              free_irq(buttons_desc[i].pin_irq,&buttons_desc[i]);    //释放中断函数

       del_timer(&buttons_timer);   //删除定时器

       input_unregister_device(buttons_dev);     //卸载类下的驱动设备
       input_free_device(buttons_dev);                //释放驱动结构体
       return 0; 
}

module_init(buttons_init);
module_exit(buttons_exit);
MODULE_LICENSE("GPL v2");